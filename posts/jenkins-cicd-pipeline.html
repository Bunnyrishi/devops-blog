<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CI/CD Pipeline Implementation with Jenkins</title>
    <link rel="stylesheet" href="css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <div class="blog-post">
        <a href="index.html" class="back-button">
            <i class="fas fa-arrow-left"></i> Back to Blog
        </a>
        
        <article>
            <header class="blog-post-header">
                <h1 class="blog-post-title">CI/CD Pipeline Implementation with Jenkins</h1>
                <div class="blog-post-meta">
                    <span><i class="fas fa-calendar"></i> January 10, 2025</span>
                    <span><i class="fas fa-clock"></i> 18 min read</span>
                    <span><i class="fas fa-tag"></i> Intermediate</span>
                </div>
            </header>
            
            <div class="blog-post-content">
                <h2>What is Jenkins?</h2>
                <p>Jenkins is an open-source automation server that enables developers to build, test, and deploy applications through continuous integration and continuous deployment (CI/CD) pipelines.</p>
                
                <h2>Jenkins Installation</h2>
                <h3>Docker Installation</h3>
                <pre><code># Run Jenkins in Docker
docker run -d \
  --name jenkins \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins_home:/var/jenkins_home \
  jenkins/jenkins:lts

# Get initial admin password
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword</code></pre>
                
                <h3>Ubuntu Installation</h3>
                <pre><code># Add Jenkins repository
wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'

# Install Jenkins
sudo apt update
sudo apt install jenkins

# Start Jenkins
sudo systemctl start jenkins
sudo systemctl enable jenkins</code></pre>
                
                <h2>Basic Pipeline Structure</h2>
                <h3>Declarative Pipeline</h3>
                <pre><code>pipeline {
    agent any
    
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/user/repo.git'
            }
        }
        
        stage('Build') {
            steps {
                sh 'npm install'
                sh 'npm run build'
            }
        }
        
        stage('Test') {
            steps {
                sh 'npm test'
            }
        }
        
        stage('Deploy') {
            steps {
                sh 'docker build -t myapp .'
                sh 'docker run -d -p 3000:3000 myapp'
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            echo 'Pipeline succeeded!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}</code></pre>
                
                <h2>Advanced Pipeline Features</h2>
                <h3>Parallel Execution</h3>
                <pre><code>pipeline {
    agent any
    stages {
        stage('Parallel Tests') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh 'npm run test:unit'
                    }
                }
                stage('Integration Tests') {
                    steps {
                        sh 'npm run test:integration'
                    }
                }
                stage('Linting') {
                    steps {
                        sh 'npm run lint'
                    }
                }
            }
        }
    }
}</code></pre>
                
                <h3>Conditional Stages</h3>
                <pre><code>pipeline {
    agent any
    stages {
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                sh 'deploy-to-staging.sh'
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Deploy to production?', ok: 'Deploy'
                sh 'deploy-to-production.sh'
            }
        }
    }
}</code></pre>
                
                <h2>Environment Variables and Parameters</h2>
                <pre><code>pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Target environment'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip test execution'
        )
    }
    
    environment {
        APP_NAME = 'myapp'
        VERSION = "${BUILD_NUMBER}"
        DOCKER_REGISTRY = 'registry.example.com'
    }
    
    stages {
        stage('Build') {
            steps {
                sh "docker build -t ${DOCKER_REGISTRY}/${APP_NAME}:${VERSION} ."
            }
        }
    }
}</code></pre>
                
                <h2>Docker Integration</h2>
                <h3>Building and Pushing Images</h3>
                <pre><code>pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = 'your-registry.com'
        IMAGE_NAME = 'myapp'
    }
    
    stages {
        stage('Build Docker Image') {
            steps {
                script {
                    def image = docker.build("${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}")
                    docker.withRegistry('https://your-registry.com', 'registry-credentials') {
                        image.push()
                        image.push('latest')
                    }
                }
            }
        }
    }
}</code></pre>
                
                <h2>Kubernetes Deployment</h2>
                <pre><code>pipeline {
    agent any
    
    stages {
        stage('Deploy to Kubernetes') {
            steps {
                withKubeConfig([credentialsId: 'kubeconfig']) {
                    sh '''
                        kubectl set image deployment/myapp \
                            myapp=${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}
                        kubectl rollout status deployment/myapp
                    '''
                }
            }
        }
    }
}</code></pre>
                
                <h2>Testing Integration</h2>
                <h3>Unit Tests with Coverage</h3>
                <pre><code>pipeline {
    agent any
    
    stages {
        stage('Test') {
            steps {
                sh 'npm test -- --coverage'
            }
            post {
                always {
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'coverage',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ])
                }
            }
        }
    }
}</code></pre>
                
                <h2>Security Scanning</h2>
                <pre><code>pipeline {
    agent any
    
    stages {
        stage('Security Scan') {
            parallel {
                stage('SAST') {
                    steps {
                        sh 'sonar-scanner'
                    }
                }
                stage('Dependency Check') {
                    steps {
                        sh 'npm audit'
                        sh 'safety check'
                    }
                }
                stage('Container Scan') {
                    steps {
                        sh 'trivy image myapp:latest'
                    }
                }
            }
        }
    }
}</code></pre>
                
                <h2>Notifications</h2>
                <pre><code>pipeline {
    agent any
    
    stages {
        // ... other stages
    }
    
    post {
        success {
            slackSend(
                channel: '#deployments',
                color: 'good',
                message: "✅ Deployment successful: ${env.JOB_NAME} - ${env.BUILD_NUMBER}"
            )
        }
        failure {
            emailext(
                subject: "❌ Build Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                body: "Build failed. Check console output at ${env.BUILD_URL}",
                to: "${env.CHANGE_AUTHOR_EMAIL}"
            )
        }
    }
}</code></pre>
                
                <h2>Multi-branch Pipeline</h2>
                <pre><code>pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                sh 'make build'
            }
        }
        
        stage('Test') {
            steps {
                sh 'make test'
            }
        }
        
        stage('Deploy') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    if (env.BRANCH_NAME == 'main') {
                        sh 'deploy-to-prod.sh'
                    } else if (env.BRANCH_NAME == 'develop') {
                        sh 'deploy-to-staging.sh'
                    }
                }
            }
        }
    }
}</code></pre>
                
                <h2>Jenkins Configuration as Code</h2>
                <pre><code># jenkins.yaml
jenkins:
  systemMessage: "Jenkins configured automatically by JCasC"
  
  securityRealm:
    local:
      allowsSignup: false
      users:
       - id: admin
         password: ${JENKINS_ADMIN_PASSWORD}
         
  authorizationStrategy:
    globalMatrix:
      permissions:
        - "Overall/Administer:admin"
        - "Overall/Read:authenticated"

jobs:
  - script: >
      multibranchPipelineJob('my-app') {
        branchSources {
          git {
            id('my-app')
            remote('https://github.com/user/my-app.git')
          }
        }
      }</code></pre>
                
                <h2>Best Practices</h2>
                <ul>
                    <li>Use declarative pipelines over scripted</li>
                    <li>Implement proper error handling</li>
                    <li>Use shared libraries for common functions</li>
                    <li>Secure credentials with Jenkins credentials store</li>
                    <li>Implement proper testing at each stage</li>
                    <li>Use parallel execution where possible</li>
                    <li>Monitor pipeline performance and optimize</li>
                    <li>Implement proper logging and notifications</li>
                </ul>
                
                <h2>Troubleshooting Common Issues</h2>
                <h3>Pipeline Debugging</h3>
                <pre><code>// Add debug information
pipeline {
    agent any
    stages {
        stage('Debug') {
            steps {
                sh 'env | sort'
                sh 'pwd && ls -la'
                echo "Branch: ${env.BRANCH_NAME}"
                echo "Build: ${env.BUILD_NUMBER}"
            }
        }
    }
}</code></pre>
                
                <h2>Conclusion</h2>
                <p>Jenkins provides powerful CI/CD capabilities for automating software delivery. Start with simple pipelines and gradually add advanced features like parallel execution, security scanning, and multi-environment deployments. Focus on creating reliable, maintainable pipelines that provide fast feedback to development teams.</p>
            </div>
        </article>
    </div>
</body>
</html>